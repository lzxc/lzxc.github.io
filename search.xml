<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hexo+next+github-搭建个人博客</title>
    <url>/2020/07/09/hexo-next-github-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p><img src="/images/blog/hexo+github.jpg" alt="avatar"></p>
<blockquote>
<p><code>hexo</code> + <code>next</code> + <code>githubPage</code> 搭建个人博客教程</p>
</blockquote>
<a id="more"></a>

<h1 id="一、环境配置"><a href="#一、环境配置" class="headerlink" title="一、环境配置"></a>一、环境配置</h1><p>hexo文档 : <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a><br>next文档 : <a href="https://theme-next.iissnan.com/" target="_blank" rel="noopener">https://theme-next.iissnan.com/</a><br>node: <a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">官网</a><br>github: <a href="https://github.com/" target="_blank" rel="noopener">官网</a></p>
<p>安装node与安装hexo,新建github帐号</p>
<p>以github帐号名新建一个repositories,取名为 : github帐号名+github.io,如<code>xxx.github.io</code><br><img src="/images/blog/github-new1.png" alt="avatar"></p>
<h1 id="二、Hexo的安装与基本命令"><a href="#二、Hexo的安装与基本命令" class="headerlink" title="二、Hexo的安装与基本命令"></a>二、Hexo的安装与基本命令</h1><p>安装hexo : </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i -g hexo</span><br></pre></td></tr></table></figure>

<p>初始化在本地生成Hexo相关目录 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init Note  # 初始化创建,会再桌面创建Note文件夹</span><br><span class="line">cd Note         # 进入Note目录</span><br><span class="line">npm install     # 进一步安装hexo所需文件</span><br></pre></td></tr></table></figure>
<blockquote>
<p> <strong>注: 直接执行hexo init需要在空文件夹，而hexo init xxx 类似创建空文件夹后再执行init</strong></p>
</blockquote>
<p>hexo三连 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean(or c)          # 清空已有hexo网站文件</span><br><span class="line">hexo generate(or g)   # 依据网页文本与新的CSS样式生成新网站文件</span><br><span class="line">hexo server(or s)     # 启动本地服务器,可以在localhost:4000查看网站修改效果</span><br></pre></td></tr></table></figure>

<p>将刚刚新建的repositories与远程关联</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:AAAA&#x2F;AAAA.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<h1 id="三、下载安装hexo主题"><a href="#三、下载安装hexo主题" class="headerlink" title="三、下载安装hexo主题"></a>三、下载安装hexo主题</h1><p>使用next主题 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;iissan&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure>

<blockquote>
<p>克隆完后,这时有两个配置文件,一个是hexo根目录的 <code>_config.yml</code> ,一个是next主题包的 <code>_config.yml</code> 注意区分</p>
</blockquote>
<h1 id="四、配置hexo-deploy"><a href="#四、配置hexo-deploy" class="headerlink" title="四、配置hexo-deploy"></a>四、配置hexo-deploy</h1><p>安装hexo的deploy工具 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i -S hexo-deployer-git</span><br></pre></td></tr></table></figure>

<p>修改hexo配置文件 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:xxx&#x2F;xxx.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>使用hexo-deploy发布到配置文件中的github项目 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo deploy  或  hexo d</span><br></pre></td></tr></table></figure>
<p>此时执行 <code>hexo d</code> 便能根据hexo配置的deploy字段发布到对应仓库 </p>
<p>其余hexo常用命令 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;newArticleTitle&quot;  #创建文章 可以简写为hexo n</span><br><span class="line">hexo new page &quot;newPageName&quot;  #创建页面</span><br><span class="line">hexo generate  #生成静态页面至public目录 可以简写为hexo g</span><br><span class="line">hexo deploy  #将public目录部署到github 可以简写为hexo d</span><br><span class="line">hexo server  #启动本地服务 可以简写为hexo s</span><br><span class="line">hexo help  #hexo帮助</span><br><span class="line">hexo version  #查看版本信息</span><br><span class="line">hexo s -g  #生成页面并启动本地服务</span><br><span class="line">hexo d -g  #生成页面并部署到github</span><br></pre></td></tr></table></figure>

<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>此时在浏览器输入 <code>xxx/github.io</code> 就能打开deploy上去的博客了,如果想跳转到自己购买的域名时,只需在刚刚的repositories根目录下新建 <code>CNAME</code> 的文件,写入你购买的域名即可</p>
<p><strong>注: 配置next的menu时发现跳转页面地址解析错误,只需把 <code>tags: /tags || tags</code> 中的 <code>||</code> 号左右的空格删除即可解析正确</strong></p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Npm-使用npm link</title>
    <url>/2020/10/10/npm-%E4%BD%BF%E7%94%A8npm%20link/</url>
    <content><![CDATA[<p><img src="/images/npm/npm2.jpg" alt="avatar"></p>
<blockquote>
<p>如何使用 <strong><code>npm link</code></strong> 调试npm包</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>在发布之前我们需要在本地环境保证包的可用性与安全性，不能偷偷发版后再使用 <strong>npm install</strong> 测试包，<br>这时候就要用到 <strong>npm</strong> 的自带工具指令 <strong>npm link</strong></p>
</blockquote>
<h1 id="npm-link-原理"><a href="#npm-link-原理" class="headerlink" title="npm link 原理"></a>npm link 原理</h1><p>他与 <strong>npm install -g</strong> 不同在于，<strong>npm install -g</strong> 存储路径为 <strong>/usr/local/lib/node_modules</strong>，而<strong>link</strong> 则在本地做一个快捷方式映射</p>
<p><img src="/images/npm/demo.png" alt="例子" title="例子"></p>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><ol>
<li>在本地环境的npm包项目中先<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm link</span><br></pre></td></tr></table></figure></li>
<li>在到需要使用该库的项目中<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm link xxx(&#39;你的npm包&#39;)</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>最简实现Promise</title>
    <url>/2021/02/22/%E6%9C%80%E7%AE%80%E5%AE%9E%E7%8E%B0Promise/</url>
    <content><![CDATA[<p><img src="/images/javascript/promise.jpg" alt="avatar"></p>
<blockquote>
<p>最简实现 <strong><code>Promise</code></strong></p>
</blockquote>
<a id="more"></a>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Promise(fn) &#123;</span><br><span class="line">  this.cbs &#x3D; []</span><br><span class="line"></span><br><span class="line">  const resolve &#x3D; (value) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeOut(()&#x3D;&gt;&#123;</span><br><span class="line">      this.data &#x3D; value</span><br><span class="line">      this.cbs.forEach((cb) &#x3D;&gt; cb(value))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fn(resolve)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.prototype.then &#x3D; function(onResolved) &#123;</span><br><span class="line">  return new Promise((resolve) &#x3D;&gt; &#123;</span><br><span class="line">    this.cbs.push(()&#x3D;&gt;&#123;</span><br><span class="line">      const res &#x3D; onResolved(this.data)</span><br><span class="line">      if(res instanceof Promise)&#123;</span><br><span class="line">        res.then(resolve)</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        resolve(resolve)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>先上使用例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Promise((resolve,reject) &#x3D;&gt; &#123;</span><br><span class="line">  setTime(() &#x3D;&gt; &#123;</span><br><span class="line">    resolve(1)</span><br><span class="line">  &#125;,1000)</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; then1</span><br><span class="line">.then(res &#x3D;&gt; &#123;</span><br><span class="line">    return new Promise((resolve,reject) &#x3D;&gt; &#123;</span><br><span class="line">      setTimeOut(() &#x3D;&gt; &#123;</span><br><span class="line">        resolve(2)</span><br><span class="line">      &#125;, 2000)</span><br><span class="line">    &#125;)</span><br><span class="line">    &#x2F;&#x2F; then2</span><br><span class="line">    .then(res &#x3D;&gt; &#123;</span><br><span class="line">      console.log(res)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>首先分析Promise构造函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 此处fn为new Promise传入的函数</span><br><span class="line">function Promise(fn) &#123;</span><br><span class="line">  &#x2F;&#x2F; 在实例上挂载Promise resolve时的回调函数集</span><br><span class="line">  this.cbs &#x3D; []</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 传递给Promise处理函数的resolve，相当于是原生Promise中入参处理函数中，取到的第一个参数resolve</span><br><span class="line">  &#x2F;&#x2F; 在实例上挂载处理函数的结果，并执行一遍回调函数集</span><br><span class="line">  const resolve &#x3D; (value) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeOut(() &#x3D;&gt; &#123;</span><br><span class="line">      this.data &#x3D; value</span><br><span class="line">      this.cbs.forEach((cb) &#x3D;&gt; cb(value))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 执行用户传入的函数 </span><br><span class="line">  &#x2F;&#x2F; 并且把resolve方法交给用户执行</span><br><span class="line">  fn(resolve)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Promise最重要的是链式调用，重点在then的实现方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise.prototype.then &#x3D; function(onResolved) &#123;</span><br><span class="line">  &#x2F;&#x2F; 此处this指向上面的构造函数作用域</span><br><span class="line">  return new Promise((resolve) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 每一个then，都会往this.cbs推入一个执行栈，等待后续执行</span><br><span class="line">    this.cbs.push(() &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 此处的onResolved为then内部的入参，res为执行结果</span><br><span class="line">      const res &#x3D; onResolved(this.data)</span><br><span class="line">      &#x2F;&#x2F; 如果res执行结果依旧为Promise的原型链上，即内部return new Promise，则继续将resolve传递入下一个then </span><br><span class="line">      if(res instanceof Promise) &#123;</span><br><span class="line">        res.then(resolve)</span><br><span class="line">      &#125;else &#123;</span><br><span class="line">        resolve(res)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="结合例子"><a href="#结合例子" class="headerlink" title="结合例子"></a>结合例子</h5><ol>
<li>第一次 <strong>new Promise()</strong> 执行时，返回的实例称为 <strong>promise1</strong></li>
<li><strong>then</strong> 的实现中，返回的实例称为 <strong>promise2</strong></li>
<li>第一次 <strong>new Promise().then</strong> 中，用户手动 <strong>return new Promise()</strong> 这里称为 <strong>user promise</strong></li>
<li>在 <strong>promise2</strong> 中的this，其实指向 <strong>promise1</strong>。在 <strong>promise2</strong> 中的函数会往this.cbs推入，等待执行</li>
<li>而 <strong>this.cbs.push()</strong> 中的函数，只有在 <strong>promise1</strong> resolve后才会执行。如果用户传入给 <strong>then</strong> 的执行函数中 <strong>（onResolved ）</strong> 返回了 <strong>user promise</strong> ，用户会在合适的时机执行 <strong>resolve promise2</strong> ，这时内部的 <code>if (res instanceof Promise) {   res.then(resolve)   }</code> 就会执行</li>
<li><strong>then2</strong> 中的函数只有在 <strong>promise2 resolve</strong> 后才会执行，此时 <strong>then2</strong> 是挂载到 <strong>promise2</strong> 的cbs中的，最终实现异步链式调用</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3.0-one Piece</title>
    <url>/2020/09/21/vue3.0-one%20Piece/</url>
    <content><![CDATA[<p><img src="/images/vue/vue3.x.jpg" alt="avatar"></p>
<blockquote>
<p><strong>本文主要记录v3.0至v2.0的变动</strong></p>
</blockquote>
<a id="more"></a>

<blockquote>
<p><strong>喜大普庆，vue终于发布3.0版本，代号为One-Piece，原文链接：<a href="https://github.com/vuejs/vue-next/releases/tag/v3.0.0" target="_blank" rel="noopener">v3.0.0</a></strong></p>
</blockquote>
<h2 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h2><p>适用v2.0与v3.0</p>
<p>slot插槽的改变，在v2.6版本已经在官方文档上支持v-slot，#缩写等，所以不多赘述<br>原文链接：<a href="https://cn.vuejs.org/v2/api/#slot-%E5%BA%9F%E5%BC%83" target="_blank" rel="noopener">slot</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- vue 2.x --&gt;</span><br><span class="line">&lt;foo&gt;</span><br><span class="line">  &lt;bar slot&#x3D;&quot;one&quot; slot-scope&#x3D;&quot;one&quot;&gt;</span><br><span class="line">    &lt;div slot-scope&#x3D;&quot;bar&quot;&gt;</span><br><span class="line">      &#123;&#123; one &#125;&#125; &#123;&#123; bar &#125;&#125;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;bar&gt;</span><br><span class="line"></span><br><span class="line">  &lt;bar slot&#x3D;&quot;two&quot; slot-scope&#x3D;&quot;two&quot;&gt;</span><br><span class="line">    &lt;div slot-scope&#x3D;&quot;bar&quot;&gt;</span><br><span class="line">      &#123;&#123; two &#125;&#125; &#123;&#123; bar &#125;&#125;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;bar&gt;</span><br><span class="line">&lt;&#x2F;foo&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- vue 3.x --&gt;</span><br><span class="line">&lt;foo&gt;</span><br><span class="line">  &lt;template v-slot:one&#x3D;&quot;one&quot;&gt;</span><br><span class="line">    &lt;bar v-slot&#x3D;&quot;bar&quot;&gt;</span><br><span class="line">      &lt;div&gt;&#123;&#123; one &#125;&#125; &#123;&#123; bar &#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;bar&gt;</span><br><span class="line">  &lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;template v-slot:two&#x3D;&quot;two&quot;&gt;</span><br><span class="line">    &lt;bar v-slot&#x3D;&quot;bar&quot;&gt;</span><br><span class="line">      &lt;div&gt;&#123;&#123; two &#125;&#125; &#123;&#123; bar &#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;bar&gt;</span><br><span class="line">  &lt;&#x2F;template&gt;</span><br><span class="line">&lt;&#x2F;foo&gt;</span><br></pre></td></tr></table></figure>

<h2 id="指令动态参数"><a href="#指令动态参数" class="headerlink" title="指令动态参数"></a>指令动态参数</h2><p>适用v2.0与v3.0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- v-bind with dynamic key --&gt;</span><br><span class="line">&lt;div v-bind:[key]&#x3D;&quot;value&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- v-bind shorthand with dynamic key --&gt;</span><br><span class="line">&lt;div :[key]&#x3D;&quot;value&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- v-on with dynamic event --&gt;</span><br><span class="line">&lt;div v-on:[event]&#x3D;&quot;handler&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- v-on shorthand with dynamic event --&gt;</span><br><span class="line">&lt;div @[event]&#x3D;&quot;handler&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- v-slot with dynamic name --&gt;</span><br><span class="line">&lt;foo&gt;</span><br><span class="line">  &lt;template v-slot:[name]&gt;</span><br><span class="line">    Hello</span><br><span class="line">  &lt;&#x2F;template&gt;</span><br><span class="line">&lt;&#x2F;foo&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- v-slot shorthand with dynamic name --&gt;</span><br><span class="line">&lt;!-- pending #3 --&gt;</span><br><span class="line">&lt;foo&gt;</span><br><span class="line">  &lt;template #[name]&gt;</span><br><span class="line">    Default slot</span><br><span class="line">  &lt;&#x2F;template&gt;</span><br><span class="line">&lt;&#x2F;foo&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Tree-shaking"><a href="#Tree-shaking" class="headerlink" title="Tree-shaking"></a>Tree-shaking</h2><p>适用v3.0<br>在vue3.0中api等使用方式有极大变化，而这种变化对文件压缩大小的优化有好处，不便之处就是写起来较麻烦了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- vue 2.x --&gt;</span><br><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line"></span><br><span class="line">Vue.nextTick(() &#x3D;&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line">const obj &#x3D; Vue.observable(&#123;&#125;)</span><br><span class="line"></span><br><span class="line">&lt;!-- vue 3.x --&gt;</span><br><span class="line">import Vue, &#123; nextTick, observable &#125; from &#39;vue&#39;</span><br><span class="line"></span><br><span class="line">Vue.nextTick &#x2F;&#x2F; undefined</span><br><span class="line"></span><br><span class="line">nextTick(() &#x3D;&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line">const obj &#x3D; observable(&#123;&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="sync与v-model"><a href="#sync与v-model" class="headerlink" title=".sync与v-model"></a>.sync与v-model</h2><p>这两项变动是互相影响的，.sync在v3.0直接移除，转而支持v-model多配置，具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- vue 2.x --&gt;</span><br><span class="line">&lt;MyComponent v-bind:title.sync&#x3D;&quot;title&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- vue 3.x --&gt;</span><br><span class="line">&lt;MyComponent v-model:title&#x3D;&quot;title&quot; v-model:name&#x3D;&quot;name&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- vue 2.x --&gt;</span><br><span class="line">&lt;input v-bind&#x3D;&quot;xxx&quot; v-on:change&#x3D;&quot;$emit(&#39;change&#39;, $event.target.checked)&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- vue 3.x --&gt;</span><br><span class="line">&lt;input </span><br><span class="line">:model-value&#x3D;&quot;xxx&quot; v-on:[&#39;update:model-value&#39;]&#x3D;&quot;newValue &#x3D;&gt; &#123; xxx &#x3D; newValue &#125;&quot;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h2><p>适用v3.0<br>不再需要 <strong>functional:true</strong> 选项， <strong>&lt;template functional&gt;\</strong> 标签也不支持</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- vue 2.x --&gt;</span><br><span class="line">const FunctionalComp &#x3D; &#123;</span><br><span class="line">  functional: true,</span><br><span class="line">  render(h) &#123;</span><br><span class="line">    return h(&#39;div&#39;, &#96;Hello! $&#123;props.name&#125;&#96;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&lt;!-- vue 3.x --&gt;</span><br><span class="line">import &#123; h &#125; from &#39;vue&#39;</span><br><span class="line">const FunctionalComp &#x3D; (props, &#123; slots, attrs, emit &#125;) &#x3D;&gt; &#123;</span><br><span class="line">  return h(&#39;div&#39;, &#96;Hello! $&#123;props.name&#125;&#96;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="全局api"><a href="#全局api" class="headerlink" title="全局api"></a>全局api</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- vue 2.x --&gt;</span><br><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import App from &#39;.&#x2F;App.vue&#39;</span><br><span class="line"></span><br><span class="line">Vue.config.ignoredElements &#x3D; [&#x2F;^app-&#x2F;]</span><br><span class="line">Vue.use(&#x2F;* ... *&#x2F;)</span><br><span class="line">Vue.mixin(&#x2F;* ... *&#x2F;)</span><br><span class="line">Vue.component(&#x2F;* ... *&#x2F;)</span><br><span class="line">Vue.directive(&#x2F;* ... *&#x2F;)</span><br><span class="line"></span><br><span class="line">Vue.prototype.customProperty &#x3D; () &#x3D;&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  render: h &#x3D;&gt; h(App)</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br><span class="line"></span><br><span class="line">&lt;!-- vue 3.x --&gt;</span><br><span class="line">import &#123; createApp &#125; from &#39;vue&#39;</span><br><span class="line">import App from &#39;.&#x2F;App.vue&#39;</span><br><span class="line"></span><br><span class="line">const app &#x3D; createApp(App)</span><br><span class="line"></span><br><span class="line">app.config.isCustomElement &#x3D; tag &#x3D;&gt; tag.startsWith(&#39;app-&#39;)</span><br><span class="line">app.use(&#x2F;* ... *&#x2F;)</span><br><span class="line">app.mixin(&#x2F;* ... *&#x2F;)</span><br><span class="line">app.component(&#x2F;* ... *&#x2F;)</span><br><span class="line">app.directive(&#x2F;* ... *&#x2F;)</span><br><span class="line"></span><br><span class="line">app.config.globalProperties.customProperty &#x3D; () &#x3D;&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">app.mount(App, &#39;#app&#39;)</span><br></pre></td></tr></table></figure>

<h2 id="指令钩子函数"><a href="#指令钩子函数" class="headerlink" title="指令钩子函数"></a>指令钩子函数</h2><p>适用v3.0<br>在vue 3.x中指令内部的钩子函数仿照组件声明周期了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- vue 2.x --&gt;</span><br><span class="line">const MyDirective &#x3D; &#123;</span><br><span class="line">  bind(el, binding, vnode, prevVnode) &#123;&#125;,</span><br><span class="line">  inserted() &#123;&#125;,</span><br><span class="line">  update() &#123;&#125;,</span><br><span class="line">  componentUpdated() &#123;&#125;,</span><br><span class="line">  unbind() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- vue 3.x --&gt;</span><br><span class="line">const MyDirective &#x3D; &#123;</span><br><span class="line">  beforeMount(el, binding, vnode, prevVnode) &#123;&#125;,</span><br><span class="line">  mounted() &#123;&#125;,</span><br><span class="line">  beforeUpdate() &#123;&#125;,</span><br><span class="line">  updated() &#123;&#125;,</span><br><span class="line">  beforeUnmount() &#123;&#125;, &#x2F;&#x2F; new</span><br><span class="line">  unmounted() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="transition、transition-class"><a href="#transition、transition-class" class="headerlink" title="transition、transition-class"></a>transition、transition-class</h2><p>适用v3.0<br>当<strong>template</strong>作为组件的根元素时，外部切换不会触发过渡效果<br><strong>v-enter</strong> 重命名为<strong>v-enter-from</strong>，<strong>v-leave</strong>重命名为<strong>v-leave-from</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;transition&gt;</span><br><span class="line">    &lt;div v-if&#x3D;&quot;show&quot; class&#x3D;&quot;modal&quot;&gt;&lt;slot&#x2F;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;transition&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.v-enter-from, .v-leave-to &#123;</span><br><span class="line">  opacity: 0;</span><br><span class="line">&#125;</span><br><span class="line">.v-leave-from, .v-enter-to &#123;</span><br><span class="line">  opacity: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h2><p>适用v3.0</p>
<h3 id="router-link"><a href="#router-link" class="headerlink" title="router-link"></a>router-link</h3><p><strong>router-link</strong> 新增 <strong>scope-slot</strong> 与 <strong>custom</strong> 属性，移除 <strong>tag</strong> 和 <strong>event</strong><br>这点对于封装视图组件或菜单组件尤为重要，使组件更具有语义及更纯粹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;router-link to&#x3D;&quot;&#x2F;&quot; custom v-slot&#x3D;&quot;&#123; href, navigate, isActive &#125;&quot;&gt;</span><br><span class="line">  &lt;li :class&#x3D;&quot;&#123; &#39;active&#39;: isActive &#125;&quot;&gt;</span><br><span class="line">    &lt;a :href&#x3D;&quot;href&quot; @click&#x3D;&quot;navigate&quot;&gt;</span><br><span class="line">      &lt;Icon&gt;home&lt;&#x2F;Icon&gt;&lt;span class&#x3D;&quot;xs-hidden&quot;&gt;Home&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;a&gt;</span><br><span class="line">  &lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;router-link&gt;</span><br></pre></td></tr></table></figure>

<h3 id="路由匹配所有"><a href="#路由匹配所有" class="headerlink" title="路由匹配所有"></a>路由匹配所有</h3><p>以往匹配所有路由的写法<code>{ path:&#39;*&#39; }</code>即可，现改为<code>{ path: &#39;/:catchAll(.*)&#39; }</code></p>
<h3 id="获取当前路由信息"><a href="#获取当前路由信息" class="headerlink" title="获取当前路由信息"></a>获取当前路由信息</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import router from &#39;..&#x2F;router&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">  setup () &#123;</span><br><span class="line">    const currentRoute &#x3D; router.currentRoute.value</span><br><span class="line">    console.log(currentRoute)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>router为定义vue路由的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; createRouter, createWebHashHistory &#125; from &#39;vue-router&#39;</span><br><span class="line">const router &#x3D; createRouter(&#123;</span><br><span class="line">  history: createWebHashHistory(),</span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h3><p>通过 <strong>defineAsyncComponent</strong> 函数创建  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; defineAsyncComponent &#125; from &quot;vue&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; simple usage</span><br><span class="line">const AsyncFoo &#x3D; defineAsyncComponent(() &#x3D;&gt; import(&quot;.&#x2F;Foo.vue&quot;))</span><br></pre></td></tr></table></figure>
<h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p><code>router.addRoutes</code> 是v2.x版本的新增路由方法，先新增如下方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; router.addRoute(route: RouteRecord) 动态添加路由</span><br><span class="line">&#x2F;&#x2F; router.removeRoute(name: string | symbol)，动态删除路由</span><br><span class="line">&#x2F;&#x2F; router.hasRoute(name: string | symbol): boolean ，判断路由是否存在</span><br><span class="line">&#x2F;&#x2F; router.getRoutes(): RouteRecord[] 获取路由列表</span><br><span class="line"></span><br><span class="line">router.addRoute(&#123;</span><br><span class="line">  path: &#39;&#x2F;new-route&#39;,</span><br><span class="line">  name: &#39;NewRoute&#39;,</span><br><span class="line">  component: NewRoute</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; add to the children of an existing route</span><br><span class="line">router.addRoute(&#39;ParentRoute&#39;, &#123;</span><br><span class="line">  path: &#39;new-route&#39;,</span><br><span class="line">  name: &#39;NewRoute&#39;,</span><br><span class="line">  component: NewRoute</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.removeRoute(&#39;NewRoute&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; normalized version of the records added</span><br><span class="line">const routeRecords &#x3D; router.getRoutes()</span><br></pre></td></tr></table></figure>


<h2 id="样式-scoped"><a href="#样式-scoped" class="headerlink" title="样式 scoped"></a>样式 scoped</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* 深度选择器 *&#x2F;</span><br><span class="line">::v-deep(.foo) &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* slot content 起作用 *&#x2F;</span><br><span class="line">::v-slotted(.foo) &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 全局 *&#x2F;</span><br><span class="line">::v-global(.foo) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="emits-option"><a href="#emits-option" class="headerlink" title="emits-option"></a>emits-option</h2><p>与v2.x版本相比，多了要先定义emit出去的对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Foo &#x3D; defineComponent(&#123;</span><br><span class="line">  emits: &#123;</span><br><span class="line">    submit: (payload: &#123; email: string; password: string &#125;) &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; perform runtime validation</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    onSubmit() &#123;</span><br><span class="line">      this.$emit(&#39;submit&#39;, &#123;</span><br><span class="line">        email: &#39;foo@bar.com&#39;,</span><br><span class="line">        password: 123 &#x2F;&#x2F; Type error!</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      this.$emit(&#39;non-declared-event&#39;) &#x2F;&#x2F; Type error!</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="组件根元素数量"><a href="#组件根元素数量" class="headerlink" title="组件根元素数量"></a>组件根元素数量</h2><p><strong>template</strong> 不在是限制只有一个，在v3.x中可以存在多个根元素</p>
<h2 id="v3-x中废弃"><a href="#v3-x中废弃" class="headerlink" title="v3.x中废弃"></a>v3.x中废弃</h2><ul>
<li>beforeCreate、created</li>
<li>filters</li>
<li>keycode</li>
<li>inline-template</li>
<li>data-object</li>
<li>on，off 和 $once</li>
</ul>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;定义部分</span><br><span class="line">st&#x3D;&gt;start: coding beginning</span><br><span class="line">e&#x3D;&gt;end: 秃秃秃秃，继续coding</span><br><span class="line">op1&#x3D;&gt;operation: 框架更新拉</span><br><span class="line">sub1&#x3D;&gt;subroutine: 继续使用老框架</span><br><span class="line">cond&#x3D;&gt;condition: 是否学习?:&gt;https:&#x2F;&#x2F;cn.vuejs.org&#x2F;</span><br><span class="line">io&#x3D;&gt;inputoutput: 技能提升，升职加薪</span><br><span class="line"></span><br><span class="line">st-&gt;op1-&gt;cond</span><br><span class="line">cond(yes)-&gt;io-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op1</span><br></pre></td></tr></table></figure>






]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Npm-发布教程</title>
    <url>/2020/10/10/npm-%E5%8F%91%E5%B8%83%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p><img src="/images/npm/npm1.jpg" alt="avatar"></p>
<blockquote>
<p>在 <strong>NPM</strong> 上发布自己的库</p>
</blockquote>
<a id="more"></a>

<h2 id="一、开始准备："><a href="#一、开始准备：" class="headerlink" title="一、开始准备："></a>一、开始准备：</h2><ol>
<li>首先在npm官网注册帐号 <a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm官网</a></li>
<li>在项目根目录 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure>
初始化 <strong>package.json</strong> 文件，如果已存在则不需要</li>
</ol>
<p><strong>package.json</strong> 包含几个关键字段:</p>
<ul>
<li>name: 包名，必须唯一，不能跟npm上的包重名。可以在 npm 官网搜索名字，如果存在则需要换个名字</li>
<li>version: 版本号，每次发布至 npm 都需要修改版本号，不能比上一次发布的版本号低</li>
<li>description: 描述</li>
<li>main: 入口文件，需指向我们编译后的包文件</li>
<li>keyword: 搜索关键字</li>
<li>author: 作者</li>
<li>private: 是否私有，需要修改为 false 才能发布到 npm</li>
<li>license: 开源协议</li>
</ul>
<ol start="3">
<li>添加npm帐号授权<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm adduser</span><br></pre></td></tr></table></figure>
需要输入帐号，密码，邮箱（注意需要先校验帐号绑定的邮箱才能授权成功）<br>通过以下命令可以查看是否授权成功：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm whoami</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="二、发布"><a href="#二、发布" class="headerlink" title="二、发布"></a>二、发布</h2><ol>
<li>发布普通package <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm publish</span><br></pre></td></tr></table></figure></li>
<li>发布scope package <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm publish --access&#x3D;public</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>scope-package</strong> 是npm的新特性，模块名带 <strong>@</strong>为指定作用域，每个用户都拥有自己的scope，如 <strong>@lzxc</strong> 为当前用户名</p>
<p>tips: 使用<strong>scope package</strong>好处是发布时package名不容易重复</p>
<h2 id="三、删除包"><a href="#三、删除包" class="headerlink" title="三、删除包"></a>三、删除包</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm unpublish xxx</span><br></pre></td></tr></table></figure>
<blockquote>
<p>删除后不能发布同名的包</p>
</blockquote>
<h1 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h1><p><code>npm unpublish</code> 只能在发布后24h内有效，如果超过就需要找npm客服取消发布了</p>
<h2 id="四、删除指定版本的包"><a href="#四、删除指定版本的包" class="headerlink" title="四、删除指定版本的包"></a>四、删除指定版本的包</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm unpublish xxx@xxx</span><br></pre></td></tr></table></figure>
<blockquote>
<p>删除后只能发布大于该删除包的版本号</p>
</blockquote>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语:"></a>结语:</h2><ol>
<li>确认使用npm的镜像源</li>
<li>预先检查发布包的文件内容，发布前可以通过 <strong>npm pack</strong> 查看将发布包的文件内容，一般都需要提前做好过滤文件，过滤 <strong>npm</strong> 提交规则使用 <strong>.npmignore</strong> 语法跟 <strong>.gitignore</strong> 类似，还可以<br>使用 <strong>npm link</strong> 可以参考以下文章：<a href="https://lzxc.online/2020/10/10/npm-使用npm%20link/" target="_blank" rel="noopener">npm-使用npm link</a></li>
<li>检查包名字是否与npm库中存在重复名字</li>
<li>检查版本号，每次发布都需要更新版本号，如果发布成功后发现版本号不对，可以参考以下文章： <a href="https://lzxc.online/2020/10/10/npm-删除包或指定版本包/" target="_blank" rel="noopener">删除包或指定版本包</a></li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>使用jsx封装复杂组件</title>
    <url>/2020/07/15/%E4%BD%BF%E7%94%A8jsx%E5%B0%81%E8%A3%85%E5%A4%8D%E6%9D%82%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<p><img src="/images/vue/vue-jsx-bg.png" alt="avatar"></p>
<blockquote>
<p><strong>使用 <code>jsx</code> 封装移动端级联组件</strong></p>
</blockquote>
<a id="more"></a>

<h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><p>JSX，是一个 JavaScript 的语法扩展，通常在 React 中使用。<br>在 Vue 里使用的话需安装对应包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i @vue&#x2F;babel-preset-jsx @vue&#x2F;babel-helper-vue-jsx-merge-props</span><br></pre></td></tr></table></figure>

<p>在 <strong>.babelrc</strong> 或者 <strong>bable.config.js</strong> 配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [&quot;@vue&#x2F;babel-preset-jsx&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>这里直接丢文档，里面有详细使用介绍</p>
<p><a href="https://github.com/vuejs/jsx#installation" target="_blank" rel="noopener">jsx 文档</a></p>
<h2 id="实际项目代码"><a href="#实际项目代码" class="headerlink" title="实际项目代码"></a>实际项目代码</h2><p>直接上代码：<br><strong>Cascader</strong> 是父组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; Button, Toast &#125; from &quot;vant&quot;;</span><br><span class="line">import axios from &quot;axios&quot;;</span><br><span class="line">import qs from &quot;qs&quot;;</span><br><span class="line"></span><br><span class="line">import Item from &quot;.&#x2F;item&quot;;</span><br><span class="line"></span><br><span class="line">const treeToList &#x3D; (function() &#123;</span><br><span class="line">  return function(tree, result &#x3D; [], level &#x3D; 0, parentKey &#x3D; &quot;&quot;) &#123;</span><br><span class="line">    tree.forEach(node &#x3D;&gt; &#123;</span><br><span class="line">      node.parentKey &#x3D; parentKey;</span><br><span class="line">      result.push(node);</span><br><span class="line">      node.deepIndex &#x3D; level + 1;</span><br><span class="line">      node.children &amp;&amp;</span><br><span class="line">        treeToList(node.children, result, level + 1, node[&quot;label&quot;]);</span><br><span class="line">    &#125;);</span><br><span class="line">    return result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">const mapTree &#x3D; (function() &#123;</span><br><span class="line">  return function(list) &#123;</span><br><span class="line">    const result &#x3D; &#123;&#125;;</span><br><span class="line">    list.forEach(i &#x3D;&gt; &#123;</span><br><span class="line">      if (result[i.deepIndex]) return false;</span><br><span class="line">      result[i.deepIndex] &#x3D; &#123;</span><br><span class="line">        index: i.deepIndex - 1,</span><br><span class="line">        deepIndex: i.deepIndex,</span><br><span class="line">        value: &quot;&quot;,</span><br><span class="line">        columns: list.filter(item &#x3D;&gt; item.deepIndex &#x3D;&#x3D;&#x3D; i.deepIndex)</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">    return result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Cascader&quot;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    value: &#123; type: Array &#125;,</span><br><span class="line">    visible: &#123; type: Boolean, default: false &#125;,</span><br><span class="line">    item: &#123; type: Object &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    calculateValue: &#123;</span><br><span class="line">      get() &#123;</span><br><span class="line">        return this.value;</span><br><span class="line">      &#125;,</span><br><span class="line">      set(v) &#123;</span><br><span class="line">        this.$emit(&quot;input&quot;, v);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    stepItem() &#123;</span><br><span class="line">      if (!Object.keys(this.pickerArr).length) return null;</span><br><span class="line">      return this.pickerArr[this.stepIndex + 1];</span><br><span class="line">    &#125;,</span><br><span class="line">    defaultSelectIndex() &#123;</span><br><span class="line">      if (!this.calculateValue?.length) return 0;</span><br><span class="line">      if (!this.stepItem?.columns) return 0;</span><br><span class="line">      const current &#x3D; this.calculateValue[this.stepIndex];</span><br><span class="line">      const defaultItem &#x3D; this.stepItem.columns.findIndex(</span><br><span class="line">        i &#x3D;&gt; i[this.pickTitle] &#x3D;&#x3D;&#x3D; current</span><br><span class="line">      );</span><br><span class="line">      return defaultItem;</span><br><span class="line">    &#125;,</span><br><span class="line">    hasNext() &#123;</span><br><span class="line">      if (!Object.keys(this.pickerArr).length) return false;</span><br><span class="line">      return !!this.pickerArr[this.stepIndex + 2]?.columns.length;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      &#x2F;&#x2F; 原数据数组</span><br><span class="line">      resultArr: [],</span><br><span class="line">      stepIndex: 0,</span><br><span class="line">      pickTitle: &quot;&quot;,</span><br><span class="line">      &#x2F;&#x2F;   格式化后树结构</span><br><span class="line">      pickerArr: [],</span><br><span class="line">      &#x2F;&#x2F; 选择过的数组</span><br><span class="line">      selectArr: [],</span><br><span class="line">      isClosed: false</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    this.init();</span><br><span class="line">    this.stepIndex &#x3D; 0;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    &#x2F;&#x2F; 过滤出当前层级下的所有数据</span><br><span class="line">    filterPick(arr) &#123;</span><br><span class="line">      if (!arr) return [];</span><br><span class="line">      const currentPerent &#x3D; this.selectArr[this.stepIndex - 1];</span><br><span class="line">      if (!currentPerent) return arr;</span><br><span class="line">      return arr.filter(item &#x3D;&gt; &#123;</span><br><span class="line">        if (item.parentKey &#x3D;&#x3D;&#x3D; &quot;&quot;) return true;</span><br><span class="line">        return item.parentKey &#x3D;&#x3D; currentPerent;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    async init() &#123;</span><br><span class="line">      &#x2F;&#x2F; 判断是使用后台配置的数据还是另使用请求接口的数据</span><br><span class="line">      const isRemote &#x3D; !!this.item?.targetSource?.relationField;</span><br><span class="line">      &#x2F;&#x2F; resultArr为判断后取到的树数据，按照树结构层级过滤成自定义的数据</span><br><span class="line">      const tree &#x3D; treeToList(this.resultArr);</span><br><span class="line">      &#x2F;&#x2F; 过滤成所需要的结构</span><br><span class="line">      this.pickerArr &#x3D; mapTree(tree);</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 远程请求方法</span><br><span class="line">    fetch() &#123;&#125;,</span><br><span class="line">    confirm(val, index) &#123;</span><br><span class="line">      if (!this.hasNext) &#123;</span><br><span class="line">        &#x2F;&#x2F; this.selectArr[this.stepIndex] &#x3D; val[this.pickTitle];</span><br><span class="line">        this.selectArr.push(val[this.pickTitle]);</span><br><span class="line">        this.calculateValue &#x3D; this.selectArr;</span><br><span class="line">        this.$emit(&quot;update:visible&quot;, false);</span><br><span class="line">        this.$nextTick(() &#x3D;&gt; &#123;</span><br><span class="line">          this.selectArr &#x3D; [];</span><br><span class="line">        &#125;);</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">      if (!this.stepItem.columns[index]?.children?.length) &#123;</span><br><span class="line">        Toast.fail(&quot;当前选项没有下一级&quot;);</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">      this.selectArr.push(val[this.pickTitle]);</span><br><span class="line">      this.stepIndex++;</span><br><span class="line">    &#125;,</span><br><span class="line">    cancel() &#123;</span><br><span class="line">      if (this.stepIndex &#x3D;&#x3D;&#x3D; 0) return;</span><br><span class="line">      this.stepIndex--;</span><br><span class="line">      this.selectArr.pop();</span><br><span class="line">    &#125;,</span><br><span class="line">    btnCancel() &#123;</span><br><span class="line">      this.$emit(&quot;update:visible&quot;, false);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  render() &#123;</span><br><span class="line">    const itemAttrs &#x3D; &#123;</span><br><span class="line">      attrs: &#123;</span><br><span class="line">        value: this.visible,</span><br><span class="line">        position: &quot;bottom&quot;,</span><br><span class="line">        getContainer: () &#x3D;&gt; document.getElementById(&quot;chooseDom&quot;),</span><br><span class="line">        &quot;value-key&quot;: this.pickTitle,</span><br><span class="line">        closeOnClickOverlay: false,</span><br><span class="line">        confirmButtonText:</span><br><span class="line">          this.stepIndex &gt;&#x3D; 0 &amp;&amp; this.hasNext ? &quot;下一步&quot; : &quot;确定&quot;,</span><br><span class="line">        cancelButtonText: this.stepIndex &#x3D;&#x3D;&#x3D; 0 ? &quot; &quot; : &quot;上一步&quot;,</span><br><span class="line">        columns: this.filterPick(this.stepItem?.columns),</span><br><span class="line">        &quot;default-index&quot;: this.defaultSelectIndex,</span><br><span class="line">        &quot;close-on-popstate&quot;: true</span><br><span class="line">      &#125;,</span><br><span class="line">      on: &#123;</span><br><span class="line">        confirm: this.confirm,</span><br><span class="line">        cancel: this.cancel</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div id&#x3D;&quot;cascaderContainer&quot;&gt;</span><br><span class="line">      &#x2F;&#x2F; 选中后回显以&#39; &#x2F; &#39;隔开</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &#123;this.calculateValue</span><br><span class="line">            ? this.calculateValue</span><br><span class="line">                .map(i &#x3D;&gt; &#96; &#x2F; $&#123;i&#125;&#96;)</span><br><span class="line">                .join(&quot;&quot;)</span><br><span class="line">                .substr(3)</span><br><span class="line">            : &quot;&quot;&#125;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;Item &#123;...itemAttrs&#125;&gt;</span><br><span class="line">          &lt;Button</span><br><span class="line">            slot&#x3D;&quot;btn&quot;</span><br><span class="line">            text&#x3D;&#123;&quot;取消&quot;&#125;</span><br><span class="line">            style&#x3D;&#123;&#123; width: &quot;100%&quot; &#125;&#125;</span><br><span class="line">            onClick&#x3D;&#123;this.btnCancel&#125;</span><br><span class="line">          &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;Item&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Item</strong> 是 <strong>Cascader</strong> 的子元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; Popup, Picker &#125; from &quot;vant&quot;;</span><br><span class="line"></span><br><span class="line">var getPropsAndAttrs &#x3D; (function() &#123;</span><br><span class="line">  return function(attrs, props) &#123;</span><br><span class="line">    const propsObj &#x3D; &#123;&#125;;</span><br><span class="line">    for (const k in props) &#123;</span><br><span class="line">      if (props.hasOwnProperty(k)) &#123;</span><br><span class="line">        const &#123; default: defaultValue &#125; &#x3D; props[k];</span><br><span class="line">        propsObj[k] &#x3D; defaultValue;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Object.keys(attrs).forEach(key &#x3D;&gt; &#123;</span><br><span class="line">      const attrKey &#x3D; getCamelCase(key);</span><br><span class="line">      if (!propsObj.hasOwnProperty(attrKey)) return;</span><br><span class="line">      const attrsVal &#x3D; attrs[key] &#x3D;&#x3D;&#x3D; &quot;&quot; ? true : attrs[key];</span><br><span class="line">      delete propsObj[attrKey];</span><br><span class="line">      propsObj[attrKey] &#x3D; attrsVal;</span><br><span class="line">    &#125;);</span><br><span class="line">    return &#123; props: propsObj &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 兼容驼峰入参</span><br><span class="line">var getCamelCase &#x3D; (function() &#123;</span><br><span class="line">  return function(str) &#123;</span><br><span class="line">    return str.replace(&#x2F;-([a-z])&#x2F;g, function(all, i) &#123;</span><br><span class="line">      return i.toUpperCase();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;CascaderItem&quot;,</span><br><span class="line">  render() &#123;</span><br><span class="line">    const ctx &#x3D; this;</span><br><span class="line">    const &#123; props: PopupDefaultProps &#125; &#x3D; getPropsAndAttrs(</span><br><span class="line">      this.$attrs,</span><br><span class="line">      Popup.props</span><br><span class="line">    );</span><br><span class="line">    const &#123; props: pickerDefaultProps &#125; &#x3D; getPropsAndAttrs(</span><br><span class="line">      this.$attrs,</span><br><span class="line">      Picker.props</span><br><span class="line">    );</span><br><span class="line">    const popupAttr &#x3D; &#123;</span><br><span class="line">      props: &#123;</span><br><span class="line">        ...PopupDefaultProps,</span><br><span class="line">        ...this.$attrs,</span><br><span class="line">        value: this.$attrs.value</span><br><span class="line">      &#125;,</span><br><span class="line">      on: &#123;</span><br><span class="line">        input: e &#x3D;&gt; &#123;</span><br><span class="line">          this.$emit(&quot;update:visible&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      style: &#123;</span><br><span class="line">        display: &quot;flex&quot;,</span><br><span class="line">        flexDirection: &quot;column&quot;,</span><br><span class="line">        background: &quot;#f7f8fa&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    const pickerAttr &#x3D; &#123;</span><br><span class="line">      props: &#123;</span><br><span class="line">        ...pickerDefaultProps,</span><br><span class="line">        showToolbar: true</span><br><span class="line">      &#125;,</span><br><span class="line">      on: &#123;</span><br><span class="line">        ...ctx.$listeners</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Popup &#123;...popupAttr&#125;&gt;</span><br><span class="line">          &lt;Picker &#123;...pickerAttr&#125; &#x2F;&gt;</span><br><span class="line">          &#123;this.$slots.btn&#125;</span><br><span class="line">        &lt;&#x2F;Popup&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>pc 端配置数据：<br><img src="/images/vue/vue-jsx1.png" alt="avatar"></p>
<p>移动端展示效果：<br><img src="/images/vue/vue-jsx.gif" alt="avatar"></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器输入URL后发生什么</title>
    <url>/2021/02/02/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<img src="/images/browser/inter-to-browser.jpg" style="height:350px;">

<blockquote>
<p>浏览器输入URL后发生什么</p>
</blockquote>
<a id="more"></a>
<h2 id="合成URL"><a href="#合成URL" class="headerlink" title="合成URL"></a>合成URL</h2><p>用户输入URL后，浏览器会根据用户输入的信息判断是搜索还是网址，如果是搜索内容，就将搜索内容+默认搜索引擎合成新的URL，如果用户输入的内容符合URL规则，浏览器就会根据URL协议，在这段内容上加上协议合成合法的URL</p>
<h2 id="DNS域名解析"><a href="#DNS域名解析" class="headerlink" title="DNS域名解析"></a>DNS域名解析</h2><p>DNS是什么，可以理解为一个电话薄。<br>例如 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> ，其中 <strong>baidu</strong> 就是DNS服务器对外公开的域名，其真实的ip地址为 <strong>103.235.46.39</strong><br>DNS 服务器可以将名称请求转换为 IP 地址</p>
<p>而其中DNS查询是一个复杂过程，整体流程大致如下</p>
<p><img src="/images/browser/browser-workflow.jpg" alt="avatar"></p>
<h2 id="建立TCP链接"><a href="#建立TCP链接" class="headerlink" title="建立TCP链接"></a>建立TCP链接</h2><p>这里包括三次握手与四次握手<br>首先，判断是不是https的，如果是，则HTTPS其实是HTTP + SSL / TLS 两部分组成，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。</p>
<p>进行三次握手，建立TCP连接。</p>
<ol>
<li><p>第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；</p>
</li>
<li><p>第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；</p>
</li>
<li><p>第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。</p>
</li>
</ol>
<h3 id="SSL握手过程"><a href="#SSL握手过程" class="headerlink" title="SSL握手过程"></a>SSL握手过程</h3><p>第一阶段 建立安全能力 包括协议版本 会话Id 密码构件 压缩方法和初始随机数<br>第二阶段 服务器发送证书 密钥交换数据和证书请求，最后发送请求-相应阶段的结束信号<br>第三阶段 如果有证书请求客户端发送此证书 之后客户端发送密钥交换数据 也可以发送证书验证消息<br>第四阶段 变更密码构件和结束握手协议<br>完成了之后，客户端和服务器端就可以开始传送数据。更多 HTTPS 的资料可以看这里：</p>
<p><a href="https://zhuanlan.zhihu.com/p/26682342" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26682342</a><br><a href="https://segmentfault.com/a/1190000012196642" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012196642</a><br>备注</p>
<p>ACK：此标志表示应答域有效，就是说前面所说的TCP应答号将会包含在TCP数据包中；有两个取值：0和1，为1的时候表示应答域有效，反之为0。TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1。</p>
<p>SYN(SYNchronization)：在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1. 因此, SYN置1就表示这是一个连接请求或连接接受报文。</p>
<p>FIN(finis）即完，终结的意思， 用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。</p>
<h2 id="发送HTTP请求"><a href="#发送HTTP请求" class="headerlink" title="发送HTTP请求"></a>发送HTTP请求</h2><p>此处涉及客户端对服务器发起请求，服务器根据请求体，请求头，协议等返回客户端需要数据或文件</p>
<h2 id="关闭TCP链接"><a href="#关闭TCP链接" class="headerlink" title="关闭TCP链接"></a>关闭TCP链接</h2><ol>
<li><p>第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；</p>
</li>
<li><p>第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我”同意”你的关闭请求；</p>
</li>
<li><p>第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；</p>
</li>
<li><p>第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</p>
</li>
</ol>
<h2 id="浏览器渲染"><a href="#浏览器渲染" class="headerlink" title="浏览器渲染"></a>浏览器渲染</h2><p>按照渲染的时间顺序，流水线可分为如下几个子阶段：构建 DOM 树、样式计算、布局阶段、分层、栅格化和显示。如图：<br><img src="/images/browser/browser-workflow1.jpg" style="height:250px;"></p>
<ol>
<li>渲染进程将 HTML 内容转换为能够读懂DOM 树结构。</li>
<li>渲染引擎将 CSS 样式表转化为浏览器可以理解的styleSheets，计算出 DOM 节点的样式。</li>
<li>创建布局树，并计算元素的布局信息。</li>
<li>对布局树进行分层，并生成分层树。</li>
<li>为每个图层生成绘制列表，并将其提交到合成线程。合成线程将图层分图块，并栅格化将图块转换成位图。</li>
<li>合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上。</li>
</ol>
<h3 id="构建DOM树"><a href="#构建DOM树" class="headerlink" title="构建DOM树"></a>构建DOM树</h3><img src="/images/browser/browser-workflow2.jpg" style="height:250px;">

<p>具体步骤：</p>
<ol>
<li>转码（Bytes -&gt; Characters）—— 读取接收到的 HTML 二进制数据，按指定编码格式将字节转换为 HTML 字符串</li>
<li>Tokens 化（Characters -&gt; Tokens）—— 解析 HTML，将 HTML 字符串转换为结构清晰的 Tokens，每个 Token 都有特殊的含义同时有自己的一套规则</li>
<li>构建 Nodes（Tokens -&gt; Nodes）—— 每个 Node 都添加特定的属性（或属性访问器），通过指针能够确定 Node 的父、子、兄弟关系和所属 treeScope（例如：iframe 的 treeScope 与外层页面的 treeScope 不同）</li>
<li>构建 DOM 树（Nodes -&gt; DOM Tree）—— 最重要的工作是建立起每个结点的父子兄弟关系</li>
</ol>
<h3 id="样式计算"><a href="#样式计算" class="headerlink" title="样式计算"></a>样式计算</h3><p>渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。<br>CSS 样式来源主要有 3 种，分别是通过 <strong>link 引用的外部 CSS 文件</strong>、<strong>style标签内的 CSS</strong>、<strong>元素的 style 属性内嵌的 CSS</strong>。其样式计算过程主要为</p>
<img src="/images/browser/browser-workflow3.jpg" style="height:250px;">

<p>可以看到上面的 CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。处理完成后再处理样式的继承和层叠，有些文章将这个过程称为CSSOM的构建过程。</p>
<h3 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h3><p>将DOM树与样式树进行合并，此处注意 <strong>回流</strong> 与 <strong>重塑</strong>，最终显示浏览器上，渲染完成</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>参考 帖子：<a href="https://mp.weixin.qq.com/s?__biz=MzI0MzIyMDM5Ng==&mid=2649826404&idx=1&sn=e4ccac5fe9d96b26ca1d8d347276d2b1&scene=19#wechat_redirect" target="_blank">面试官：浏览器输入URL后发生了什么？</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
</search>
